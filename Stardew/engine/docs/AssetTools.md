# Asset Tools

These are scripts and tools in the scripts folder, for specific command line usage pass -h to them

# ConvertTiled.py

Create level files for your game using the program [Tiled](https://www.mapeditor.org/). Into the object layers you can add entities that are defined however you like defined as points, lines, polygons, boxes etc. Define the entities you want this way and give them custom properties that they will need to have. Be consistant with the class names. 

Next we run a python script to convert the tiled .json file into a binary file the engine will load. To add your own type of entities to the file, extend the script the engine provides, ConvertTiled.py

```python

#
#   Serialize entity types for the game from the tiled json file
#   plugs into and extends engine/scripts/ConvertTiled.py
#

import sys
import os
import struct

print(os.path.abspath("../Stardew/engine/scripts"))
sys.path.insert(1, os.path.abspath("../Stardew/engine/scripts"))  
from ConvertTiled import main, register_entity_serializer, get_tiled_object_custom_prop

def serialize_WoodedArea(file, obj):
    # convert the json object to binary format
    # Our entity serializer needs to be able to load this 
    file.write(struct.pack("I", 1)) # version
    file.write(struct.pack("f", get_tiled_object_custom_prop(obj, "ConiferousPercentage")["value"]))
    file.write(struct.pack("f", get_tiled_object_custom_prop(obj, "DeciduousPercentage")["value"]))
    file.write(struct.pack("f", get_tiled_object_custom_prop(obj, "PerMeterDensity")["value"]))
    file.write(struct.pack("f", obj["width"]))
    file.write(struct.pack("f", obj["height"]))

def get_type_WoodedArea(obj):
    return 6                       # this corresponds to the entity type we used when we called Et2D_RegisterEntityType

register_entity_serializer("WoodedArea", serialize_WoodedArea, get_type_WoodedArea, False) # each 

main()

```

The ConvertTiled.py script takes a list of tiled json files as input

as output it will produce:
- for each input:
    - a .tilemap binary file
        - this contains the tilemaps and entities for the level
- an atlas.xml file
    - this contains the file paths of all tiles used within the all for all level files passed in and their coordinates within the file, as well as their width and height
    - the game can load an atlas from this directly or you can precompile it (recommended), see section below

# MergeAtlases.py

A tool that merges two atlases, use like so:

```shell
python3 engine/scripts/MergeAtlases.py ./Assets/out/atlas.xml ./Assets/out/named_sprites.xml > ./Assets/out/atlascombined.xml
```

Use it to combine a hand written atlas of sprites used for objects in the game with the atlas of tile sprites generated by ConvertTiled.py.

# AtlasTool

This is a tool written in C that will use an atlas.xml file to create an atlas of sprites that are defined in it. The game can quickly load this and use the individual sprites within, as it contains both the pixel data for the atlas and the coordinates of the individual sprites within.

The input xml files can also contain paths to fonts which will be rendered into the atlas at a specified size.

The tool does a passable but not great job of minimizing the overall size of the atlas given sprites of different sizes, it could be improved.

The good thing about this is one openGL texture can be used to draw the whole game layer, and it also means that only the tiles actually used, out of a potential source image of many more, need to be in the final loaded file.

In order to eliminate bleeding of texels from adjacent sprites the sprites in the atlas have a 1 pixel border that mimics GL_CLAMP_TO_EDGE texture clamping

# ExpandAnimations.py

Expands </animation> nodes in xml files. You can write an animation node like this in an atlas xml file:

```xml
<animation name="walk-base-female-down"
            fps="10.0"
            source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png"
            startx="0"
            starty="0"
            incx="64"
            incy="64"
            width="64"
            height="64"
            numFrames="9"/>
```

And this script will expand it like so:

```xml
<animation-frames name="walk-base-female-down" fps="10.0">
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="0" width="64" height="64" name="walk-base-female-down0" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="64" width="64" height="64" name="walk-base-female-down1" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="128" width="64" height="64" name="walk-base-female-down2" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="192" width="64" height="64" name="walk-base-female-down3" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="256" width="64" height="64" name="walk-base-female-down4" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="320" width="64" height="64" name="walk-base-female-down5" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="384" width="64" height="64" name="walk-base-female-down6" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="448" width="64" height="64" name="walk-base-female-down7" />
    <sprite source="./Assets/Image/lpc_base_assets/LPC Base Assets/sprites/people/female_walkcycle.png" top="128" left="512" width="64" height="64" name="walk-base-female-down8" />
</animation-frames>
```

Example usage:

```bash
python3 ./engine/scripts/ExpandAnimations.py -o ./expanded_test.xml ./Assets/out/named_sprites.xml
```

# Example Compile Assets Script

I recommend you create and maintain a compile assets script as you add assets to the game. For example:

```bash
# convert jsons from the Tiled editor to binary files containing tilemaps and entities + an atlas.xml file of the tiles used
python3 game/game_convert_tiled.py ./Assets/out -m ./Assets/Farm.json ./Assets/House.json ./Assets/RoadToTown.json 

# expand animation nodes
python3 ./engine/scripts/ExpandAnimations.py -o ./Assets/out/expanded_named_sprites.xml ./Assets/out/named_sprites.xml

# merge the list of named sprites into the ones used by the tilemap
python3 engine/scripts/MergeAtlases.py ./Assets/out/atlas.xml ./Assets/out/expanded_named_sprites.xml > ./Assets/out/atlascombined.xml

# compile the atlascombined.xml into a binary atlas file
./build/atlastool/AtlasTool ./Assets/out/atlascombined.xml -o ./Assets/out/main.atlas -bmp Atlas.bmp

# compile another atlas file containing sprites and fonts for the games UI 
./build/atlastool/AtlasTool ./Assets/ui_atlas.xml -o ./Assets/ui_atlas.atlas -bmp UIAtlas.bmp

```
A make file would be even better.

